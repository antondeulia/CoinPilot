/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from '@prisma/client/runtime/client'
import type * as Prisma from './prismaNamespace.js'

const config: runtime.GetPrismaClientConfig = {
	previewFeatures: [],
	clientVersion: '7.3.0',
	engineVersion: '9d6ad21cbbceab97458517b147a6a09ff43aa735',
	activeProvider: 'postgresql',
	inlineSchema:
		'generator client {\n  provider     = "prisma-client"\n  output       = "../src/generated/prisma"\n  moduleFormat = "cjs"\n}\n\ndatasource db {\n  provider = "postgresql"\n}\n\nmodel User {\n  id                  String               @id @default(uuid())\n  telegramId          String               @unique\n  activeAccountId     String?\n  defaultAccountId    String?\n  mainCurrency        String               @default("USD")\n  accounts            Account[]\n  transactions        Transaction[]\n  categories          Category[]\n  tags                Tag[]\n  savedAnalyticsViews SavedAnalyticsView[]\n  alertConfigs        AlertConfig[]\n  createdAt           DateTime             @default(now())\n\n  @@map("users")\n}\n\nmodel Account {\n  id        String          @id @default(uuid())\n  userId    String\n  user      User            @relation(fields: [userId], references: [id])\n  name      String\n  type      AccountTypeEnum\n  currency  String\n  isHidden  Boolean         @default(false)\n  createdAt DateTime        @default(now())\n\n  transactions     Transaction[]\n  transactionsFrom Transaction[]  @relation("FromAccount")\n  transactionsTo   Transaction[]  @relation("ToAccount")\n  assets           AccountAsset[]\n\n  @@map("accounts")\n}\n\nmodel AccountAsset {\n  id        String  @id @default(uuid())\n  accountId String\n  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)\n  currency  String\n  amount    Float\n\n  @@unique([accountId, currency])\n  @@map("account_assets")\n}\n\nmodel Transaction {\n  id                String                    @id @default(uuid())\n  accountId         String\n  account           Account                   @relation(fields: [accountId], references: [id])\n  amount            Float\n  currency          String\n  direction         TransactionDirectionsEnum\n  category          String?\n  description       String?\n  rawText           String\n  transactionDate   DateTime                  @default(now())\n  createdAt         DateTime                  @default(now())\n  userId            String                    @map("user_id")\n  user              User                      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  fromAccountId     String?\n  fromAccount       Account?                  @relation(name: "FromAccount", fields: [fromAccountId], references: [id])\n  toAccountId       String?\n  toAccount         Account?                  @relation(name: "ToAccount", fields: [toAccountId], references: [id])\n  tagId             String?\n  tag               Tag?                      @relation(fields: [tagId], references: [id])\n  convertedAmount   Float?\n  convertToCurrency String?\n\n  @@map("transactions")\n}\n\nmodel Category {\n  id        String   @id @default(uuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id])\n  name      String\n  createdAt DateTime @default(now())\n\n  @@map("categories")\n}\n\nmodel Tag {\n  id           String        @id @default(uuid())\n  userId       String\n  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  name         String\n  usageCount   Int           @default(0)\n  createdAt    DateTime      @default(now())\n  aliases      TagAlias[]\n  transactions Transaction[]\n\n  @@unique([userId, name])\n  @@map("tags")\n}\n\nmodel TagAlias {\n  id        String   @id @default(uuid())\n  tagId     String\n  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)\n  alias     String\n  createdAt DateTime @default(now())\n\n  @@map("tag_aliases")\n}\n\nmodel TagAuditLog {\n  id        String   @id @default(uuid())\n  userId    String\n  action    String\n  details   String\n  createdAt DateTime @default(now())\n\n  @@map("tag_audit_logs")\n}\n\nmodel SavedAnalyticsView {\n  id        String   @id @default(uuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  name      String\n  filters   Json\n  createdAt DateTime @default(now())\n\n  @@map("saved_analytics_views")\n}\n\nmodel AlertConfig {\n  id         String        @id @default(uuid())\n  userId     String\n  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  type       AlertTypeEnum\n  threshold  Float\n  categoryId String?\n  enabled    Boolean       @default(true)\n  createdAt  DateTime      @default(now())\n\n  @@map("alert_configs")\n}\n\n// Enums\nenum AccountTypeEnum {\n  cash\n  bank\n  crypto\n}\n\nenum TransactionDirectionsEnum {\n  income\n  expense\n  transfer\n}\n\nenum AlertTypeEnum {\n  large_expense\n  category_threshold\n}\n',
	runtimeDataModel: {
		models: {},
		enums: {},
		types: {}
	}
}

config.runtimeDataModel = JSON.parse(
	'{"models":{"User":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"telegramId","kind":"scalar","type":"String"},{"name":"activeAccountId","kind":"scalar","type":"String"},{"name":"defaultAccountId","kind":"scalar","type":"String"},{"name":"mainCurrency","kind":"scalar","type":"String"},{"name":"accounts","kind":"object","type":"Account","relationName":"AccountToUser"},{"name":"transactions","kind":"object","type":"Transaction","relationName":"TransactionToUser"},{"name":"categories","kind":"object","type":"Category","relationName":"CategoryToUser"},{"name":"tags","kind":"object","type":"Tag","relationName":"TagToUser"},{"name":"savedAnalyticsViews","kind":"object","type":"SavedAnalyticsView","relationName":"SavedAnalyticsViewToUser"},{"name":"alertConfigs","kind":"object","type":"AlertConfig","relationName":"AlertConfigToUser"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"users"},"Account":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"AccountToUser"},{"name":"name","kind":"scalar","type":"String"},{"name":"type","kind":"enum","type":"AccountTypeEnum"},{"name":"currency","kind":"scalar","type":"String"},{"name":"isHidden","kind":"scalar","type":"Boolean"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"transactions","kind":"object","type":"Transaction","relationName":"AccountToTransaction"},{"name":"transactionsFrom","kind":"object","type":"Transaction","relationName":"FromAccount"},{"name":"transactionsTo","kind":"object","type":"Transaction","relationName":"ToAccount"},{"name":"assets","kind":"object","type":"AccountAsset","relationName":"AccountToAccountAsset"}],"dbName":"accounts"},"AccountAsset":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"accountId","kind":"scalar","type":"String"},{"name":"account","kind":"object","type":"Account","relationName":"AccountToAccountAsset"},{"name":"currency","kind":"scalar","type":"String"},{"name":"amount","kind":"scalar","type":"Float"}],"dbName":"account_assets"},"Transaction":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"accountId","kind":"scalar","type":"String"},{"name":"account","kind":"object","type":"Account","relationName":"AccountToTransaction"},{"name":"amount","kind":"scalar","type":"Float"},{"name":"currency","kind":"scalar","type":"String"},{"name":"direction","kind":"enum","type":"TransactionDirectionsEnum"},{"name":"category","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"rawText","kind":"scalar","type":"String"},{"name":"transactionDate","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"userId","kind":"scalar","type":"String","dbName":"user_id"},{"name":"user","kind":"object","type":"User","relationName":"TransactionToUser"},{"name":"fromAccountId","kind":"scalar","type":"String"},{"name":"fromAccount","kind":"object","type":"Account","relationName":"FromAccount"},{"name":"toAccountId","kind":"scalar","type":"String"},{"name":"toAccount","kind":"object","type":"Account","relationName":"ToAccount"},{"name":"tagId","kind":"scalar","type":"String"},{"name":"tag","kind":"object","type":"Tag","relationName":"TagToTransaction"},{"name":"convertedAmount","kind":"scalar","type":"Float"},{"name":"convertToCurrency","kind":"scalar","type":"String"}],"dbName":"transactions"},"Category":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"CategoryToUser"},{"name":"name","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"categories"},"Tag":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"TagToUser"},{"name":"name","kind":"scalar","type":"String"},{"name":"usageCount","kind":"scalar","type":"Int"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"aliases","kind":"object","type":"TagAlias","relationName":"TagToTagAlias"},{"name":"transactions","kind":"object","type":"Transaction","relationName":"TagToTransaction"}],"dbName":"tags"},"TagAlias":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"tagId","kind":"scalar","type":"String"},{"name":"tag","kind":"object","type":"Tag","relationName":"TagToTagAlias"},{"name":"alias","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"tag_aliases"},"TagAuditLog":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"action","kind":"scalar","type":"String"},{"name":"details","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"tag_audit_logs"},"SavedAnalyticsView":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"SavedAnalyticsViewToUser"},{"name":"name","kind":"scalar","type":"String"},{"name":"filters","kind":"scalar","type":"Json"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"saved_analytics_views"},"AlertConfig":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"AlertConfigToUser"},{"name":"type","kind":"enum","type":"AlertTypeEnum"},{"name":"threshold","kind":"scalar","type":"Float"},{"name":"categoryId","kind":"scalar","type":"String"},{"name":"enabled","kind":"scalar","type":"Boolean"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":"alert_configs"}},"enums":{},"types":{}}'
)

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
	const { Buffer } = await import('node:buffer')
	const wasmArray = Buffer.from(wasmBase64, 'base64')
	return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
	getRuntime: async () =>
		await import('@prisma/client/runtime/query_compiler_fast_bg.postgresql.js'),

	getQueryCompilerWasmModule: async () => {
		const { wasm } =
			await import('@prisma/client/runtime/query_compiler_fast_bg.postgresql.wasm-base64.js')
		return await decodeBase64AsWasm(wasm)
	},

	importName: './query_compiler_fast_bg.js'
}

export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
	'log' extends keyof ClientOptions
		? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
			? Prisma.GetEvents<ClientOptions['log']>
			: never
		: never

export interface PrismaClientConstructor {
	/**
	 * ## Prisma Client
	 *
	 * Type-safe database client for TypeScript
	 * @example
	 * ```
	 * const prisma = new PrismaClient()
	 * // Fetch zero or more Users
	 * const users = await prisma.user.findMany()
	 * ```
	 *
	 * Read more in our [docs](https://pris.ly/d/client).
	 */

	new <
		Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
		LogOpts extends LogOptions<Options> = LogOptions<Options>,
		OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends {
			omit: infer U
		}
			? U
			: Prisma.PrismaClientOptions['omit'],
		ExtArgs extends runtime.Types.Extensions.InternalArgs =
			runtime.Types.Extensions.DefaultArgs
	>(
		options: Prisma.Subset<Options, Prisma.PrismaClientOptions>
	): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 *
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
	in LogOpts extends Prisma.LogLevel = never,
	in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,
	in out ExtArgs extends runtime.Types.Extensions.InternalArgs =
		runtime.Types.Extensions.DefaultArgs
> {
	[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

	$on<V extends LogOpts>(
		eventType: V,
		callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
	): PrismaClient

	/**
	 * Connect with the database
	 */
	$connect(): runtime.Types.Utils.JsPromise<void>

	/**
	 * Disconnect from the database
	 */
	$disconnect(): runtime.Types.Utils.JsPromise<void>

	/**
	 * Executes a prepared raw query and returns the number of affected rows.
	 * @example
	 * ```
	 * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://pris.ly/d/raw-queries).
	 */
	$executeRaw<T = unknown>(
		query: TemplateStringsArray | Prisma.Sql,
		...values: any[]
	): Prisma.PrismaPromise<number>

	/**
	 * Executes a raw query and returns the number of affected rows.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://pris.ly/d/raw-queries).
	 */
	$executeRawUnsafe<T = unknown>(
		query: string,
		...values: any[]
	): Prisma.PrismaPromise<number>

	/**
	 * Performs a prepared raw query and returns the `SELECT` data.
	 * @example
	 * ```
	 * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
	 * ```
	 *
	 * Read more in our [docs](https://pris.ly/d/raw-queries).
	 */
	$queryRaw<T = unknown>(
		query: TemplateStringsArray | Prisma.Sql,
		...values: any[]
	): Prisma.PrismaPromise<T>

	/**
	 * Performs a raw query and returns the `SELECT` data.
	 * Susceptible to SQL injections, see documentation.
	 * @example
	 * ```
	 * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
	 * ```
	 *
	 * Read more in our [docs](https://pris.ly/d/raw-queries).
	 */
	$queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>

	/**
	 * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
	 * @example
	 * ```
	 * const [george, bob, alice] = await prisma.$transaction([
	 *   prisma.user.create({ data: { name: 'George' } }),
	 *   prisma.user.create({ data: { name: 'Bob' } }),
	 *   prisma.user.create({ data: { name: 'Alice' } }),
	 * ])
	 * ```
	 *
	 * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
	 */
	$transaction<P extends Prisma.PrismaPromise<any>[]>(
		arg: [...P],
		options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
	): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

	$transaction<R>(
		fn: (
			prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
		) => runtime.Types.Utils.JsPromise<R>,
		options?: {
			maxWait?: number
			timeout?: number
			isolationLevel?: Prisma.TransactionIsolationLevel
		}
	): runtime.Types.Utils.JsPromise<R>

	$extends: runtime.Types.Extensions.ExtendsHook<
		'extends',
		Prisma.TypeMapCb<OmitOpts>,
		ExtArgs,
		runtime.Types.Utils.Call<
			Prisma.TypeMapCb<OmitOpts>,
			{
				extArgs: ExtArgs
			}
		>
	>

	/**
	 * `prisma.user`: Exposes CRUD operations for the **User** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Users
	 * const users = await prisma.user.findMany()
	 * ```
	 */
	get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.account`: Exposes CRUD operations for the **Account** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Accounts
	 * const accounts = await prisma.account.findMany()
	 * ```
	 */
	get account(): Prisma.AccountDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.accountAsset`: Exposes CRUD operations for the **AccountAsset** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more AccountAssets
	 * const accountAssets = await prisma.accountAsset.findMany()
	 * ```
	 */
	get accountAsset(): Prisma.AccountAssetDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Transactions
	 * const transactions = await prisma.transaction.findMany()
	 * ```
	 */
	get transaction(): Prisma.TransactionDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.category`: Exposes CRUD operations for the **Category** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Categories
	 * const categories = await prisma.category.findMany()
	 * ```
	 */
	get category(): Prisma.CategoryDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more Tags
	 * const tags = await prisma.tag.findMany()
	 * ```
	 */
	get tag(): Prisma.TagDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.tagAlias`: Exposes CRUD operations for the **TagAlias** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more TagAliases
	 * const tagAliases = await prisma.tagAlias.findMany()
	 * ```
	 */
	get tagAlias(): Prisma.TagAliasDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.tagAuditLog`: Exposes CRUD operations for the **TagAuditLog** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more TagAuditLogs
	 * const tagAuditLogs = await prisma.tagAuditLog.findMany()
	 * ```
	 */
	get tagAuditLog(): Prisma.TagAuditLogDelegate<ExtArgs, { omit: OmitOpts }>

	/**
	 * `prisma.savedAnalyticsView`: Exposes CRUD operations for the **SavedAnalyticsView** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more SavedAnalyticsViews
	 * const savedAnalyticsViews = await prisma.savedAnalyticsView.findMany()
	 * ```
	 */
	get savedAnalyticsView(): Prisma.SavedAnalyticsViewDelegate<
		ExtArgs,
		{ omit: OmitOpts }
	>

	/**
	 * `prisma.alertConfig`: Exposes CRUD operations for the **AlertConfig** model.
	 * Example usage:
	 * ```ts
	 * // Fetch zero or more AlertConfigs
	 * const alertConfigs = await prisma.alertConfig.findMany()
	 * ```
	 */
	get alertConfig(): Prisma.AlertConfigDelegate<ExtArgs, { omit: OmitOpts }>
}

export function getPrismaClientClass(): PrismaClientConstructor {
	return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
